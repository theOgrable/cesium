<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no">
    <meta name="description" content="Shadow maps.">
    <meta name="cesium-sandcastle-labels" content="Tutorials,Showcases">
    <title>Cesium Demo</title>
    <script type="text/javascript" src="../Sandcastle-header.js"></script>
    <script type="text/javascript" src="../../../ThirdParty/requirejs-2.1.20/require.js"></script>
    <script type="text/javascript">
    require.config({
        baseUrl : '../../../Source',
        waitSeconds : 60
    });
    </script>
</head>
<body class="sandcastle-loading" data-sandcastle-bucket="bucket-requirejs.html">
<style>
    @import url(../templates/bucket.css);
    #toolbar input[type=range] {
        width : 70px;
    }
    #toolbar input {
        vertical-align: middle;
        padding-top: 2px;
        padding-bottom: 2px;
    }
</style>
<div id="cesiumContainer" class="fullSize"></div>
<div id="loadingOverlay"><h1>Loading...</h1></div>
<div id="toolbar">
    <table><tbody>
        <tr>
            <td data-bind="style: { color: lightHorizonEnabled ? '' : 'gray'}">Light Horizon</td>
            <td>
                <input type="range" min="0" max="90" step="1.0" data-bind="value: lightHorizon, valueUpdate: 'input', enable: lightHorizonEnabled">
                <input type="text" size="2" data-bind="value: lightHorizon, enable: lightHorizonEnabled">
            </td>
        </tr>
        <tr>
            <td data-bind="style: { color: lightAngleEnabled ? '' : 'gray'}">Light Angle</td>
            <td>
                <input type="range" min="0" max="360" step="1.0" data-bind="value: lightAngle, valueUpdate: 'input', enable: lightAngleEnabled">
                <input type="text" size="2" data-bind="value: lightAngle, enable: lightAngleEnabled">
            </td>
        </tr>
        <tr>
            <td data-bind="style: { color: distanceEnabled ? '' : 'gray'}">Distance Limit</td>
            <td>
                <input type="range" min="100.0" max="10000.0" step="1.0" data-bind="value: distance, valueUpdate: 'input', enable: distanceEnabled">
                <input type="text" size="2" data-bind="value: distance, enable: distanceEnabled">
            </td>
        </tr>
        <tr>
            <td data-bind="style: { color: radiusEnabled ? '' : 'gray'}">Radius</td>
            <td>
                <input type="range" min="10.0" max="1000.0" step="1.0" data-bind="value: radius, valueUpdate: 'input', enable: radiusEnabled">
                <input type="text" size="2" data-bind="value: radius, enable: radiusEnabled">
            </td>
        </tr>
        <tr>
            <td data-bind="style: { color: cascadesEnabled ? '' : 'gray'}">Cascades</td>
            <td><select data-bind="options: cascadeOptions, value: cascades, enable: cascadesEnabled"/></td>
        </tr>
        <tr>
            <td>Light Source</td>
            <td><select data-bind="options: lightSourceOptions, value: lightSource"/></td>
        </tr>
        <tr>
            <td>Texture Size</td>
            <td><select data-bind="options: sizeOptions, value: size"/></td>
        </tr>
        <tr>
            <td>Shadows Enabled</td>
            <td><input type="checkbox" data-bind="checked: shadows"/></td>
        </tr>
        <tr>
            <td>Terrain Enabled</td>
            <td><input type="checkbox" data-bind="checked: terrain"/></td>
        </tr>
        <tr>
            <td>Show Globe</td>
            <td><input type="checkbox" data-bind="checked: globe"/></td>
        </tr>
        <tr>
            <td data-bind="style: { color: terrainCastEnabled ? '' : 'gray'}">Terrain Cast</td>
            <td><input type="checkbox" data-bind="checked: terrainCast, enable: terrainCastEnabled"/></td>
        </tr>
        <tr>
            <td>Show debug</td>
            <td><input type="checkbox" data-bind="checked: debug"/></td>
        </tr>
        <tr>
            <td>Freeze frame</td>
            <td><input type="checkbox" data-bind="checked: freeze"/></td>
        </tr>
        <tr>
            <td data-bind="style: { color: cascadeColorsEnabled ? '' : 'gray'}">Cascade colors</td>
            <td><input type="checkbox" data-bind="checked: cascadeColors, enable: cascadeColorsEnabled"/></td>
        </tr>
        <tr>
            <td data-bind="style: { color: fitNearFarEnabled ? '' : 'gray'}">Fit near/far</td>
            <td><input type="checkbox" data-bind="checked: fitNearFar, enable: fitNearFarEnabled"/></td>
        </tr>
        <tr>
            <td data-bind="style: { color: softShadowsEnabled ? '' : 'gray'}">Soft shadows</td>
            <td><input type="checkbox" data-bind="checked: softShadows, enable: softShadowsEnabled"/></td>
        </tr>
        <tr>
            <td>Exponential Shadows</td>
            <td><input type="checkbox" data-bind="checked: exponentialShadows"/></td>
        </tr>
        <tr>
            <td>Location</td>
            <td><select data-bind="options: locationOptions, value: location"/></td>
        </tr>
        <tr>
            <td>Model</td>
            <td><select data-bind="options: modelOptions, value: model"/></td>
        </tr>
        <tr>
            <td>Model Position</td>
            <td>
                <select data-bind="options: modelPositionOptions, value: modelPosition"/>
                <input type="checkbox" data-bind="checked: grid"/>
                <span>Grid</span>
            </td>
        </tr>
        <tr>
            <td>Bias Mode</td>
            <td><select data-bind="options: biasModes, optionsText : 'type', value: biasMode"/></td>
        </tr>
        <tr>
            <td>Polygon Offset</td>
            <td>
                <input type="checkbox" data-bind="checked: biasMode.polygonOffset">
                <input type="text" size="2" data-bind="value: biasMode.polygonOffsetFactor">
                <input type="text" size="2" data-bind="value: biasMode.polygonOffsetUnits">
            </td>
        </tr>
        <tr>
            <td>Normal Offset</td>
            <td>
                <input type="checkbox" data-bind="checked: biasMode.normalOffset">
                <input type="text" size="2" data-bind="value: biasMode.normalOffsetScale">
            </td>
        </tr>
        <tr>
            <td>Normal Shading</td>
            <td>
                <input type="checkbox" data-bind="checked: biasMode.normalShading">
                <input type="text" size="2" data-bind="value: biasMode.normalShadingSmooth">
            </td>
        </tr>
        <tr>
            <td>Depth Bias</td>
            <td>
                <input type="text" size="2" data-bind="value: biasMode.depthBias">
            </td>
        </tr>
    </tbody></table>
</div>

<script id="cesium_sandcastle_script">
function startup(Cesium) {
    'use strict';
//Sandcastle_Begin


function BiasOptions(options) {
    this.type = options.type;
    this.polygonOffset = Cesium.knockout.observable(options.polygonOffset);
    this.polygonOffsetFactor = Cesium.knockout.observable(options.polygonOffsetFactor);
    this.polygonOffsetUnits = Cesium.knockout.observable(options.polygonOffsetUnits);
    this.normalOffset = Cesium.knockout.observable(options.normalOffset);
    this.normalOffsetScale = Cesium.knockout.observable(options.normalOffsetScale);
    this.normalShading = Cesium.knockout.observable(options.normalShading);
    this.normalShadingSmooth = Cesium.knockout.observable(options.normalShadingSmooth);
    this.depthBias = Cesium.knockout.observable(options.depthBias);
}

var viewModel = {
    lightAngle : 0.0,
    lightAngleEnabled : true,
    lightHorizon : 0.0,
    lightHorizonEnabled : true,
    distance : 1000.0,
    distanceEnabled : true,
    radius : 200.0,
    radiusEnabled : true,
    shadows : true,
    terrain : true,
    globe : true,
    terrainCast : true,
    terrainCastEnabled : true,
    debug : true,
    freeze : false,
    cascadeColors : false,
    cascadeColorsEnabled : true,
    fitNearFar : true,
    fitNearFarEnabled : true,
    softShadows : false,
    softShadowsEnabled : true,
    exponentialShadows : false,
    cascadeOptions : [1, 4],
    cascades : 4,
    cascadesEnabled : true,
    lightSourceOptions : ['Freeform', 'Sun', 'Fixed', 'Point', 'Spot'],
    lightSource : 'Freeform',
    sizeOptions : [256, 512, 1024, 2048],
    size : 1024,
    modelOptions : ['Wood Tower', 'Cesium Air', 'Shadow Tester', 'Shadow Tester 2', 'Shadow Tester 3', 'Shadow Tester 4', 'Shadow Tester Point'],
    model : 'Shadow Tester',
    locationOptions : ['Exton', 'Everest', 'Pinnacle PA', 'Seneca Rocks', 'Half Dome'],
    location : 'Pinnacle PA',
    modelPositionOptions : ['Center', 'Ground'],
    modelPosition : 'Center',
    grid : false,
    biasModes : [
        new BiasOptions({
            type : 'terrain',
            polygonOffset : true,
            polygonOffsetFactor : 1.1,
            polygonOffsetUnits : 4.0,
            normalOffset : true,
            normalOffsetScale : 2.0,
            normalShading : true,
            normalShadingSmooth : 0.35,
            depthBias : 0.0001
        }),
        new BiasOptions({
            type : 'primitive',
            polygonOffset : true,
            polygonOffsetFactor : 1.1,
            polygonOffsetUnits : 4.0,
            normalOffset : true,
            normalOffsetScale : 0.05,
            normalShading : true,
            normalShadingSmooth : 0.1,
            depthBias : 0.0001
        }),
        new BiasOptions({
            type : 'point',
            polygonOffset : false,
            polygonOffsetFactor : 1.1,
            polygonOffsetUnits : 4.0,
            normalOffset : false,
            normalOffsetScale : 0.0,
            normalShading : true,
            normalShadingSmooth : 0.1,
            depthBias : 0.01
        })
    ],
    biasMode : Cesium.knockout.observable()
};

// Temp values for testing
viewModel.lightSource = 'Freeform';
viewModel.lightHorizon = 71.0;
viewModel.lightAngle = 40.0;
viewModel.distance = 10000.0;
viewModel.location = 'Pinnacle PA';
viewModel.model = 'Shadow Tester';
viewModel.modelPosition = 'Center';
viewModel.terrain = true;
viewModel.terrainCast = true;

var uiOptions = {
    all : ['lightHorizon', 'lightAngle', 'distance', 'radius', 'terrainCast', 'cascades', 'cascadeColors', 'fitNearFar', 'softShadows'],
    disable : {
        'Freeform' : ['radius'],
        'Sun' : ['lightHorizon', 'lightAngle', 'radius'],
        'Fixed' : ['lightHorizon', 'lightAngle', 'distance', 'radius', 'cascades', 'cascadeColors', 'fitNearFar'],
        'Point' : ['lightHorizon', 'lightAngle', 'distance', 'cascades', 'cascadeColors', 'fitNearFar', 'softShadows'],
        'Spot' : ['lightHorizon', 'lightAngle', 'distance', 'radius', 'cascades', 'cascadeColors', 'fitNearFar']
    },
    modelUrls : {
        'Wood Tower' : '../../SampleData/models/WoodTower/Wood_Tower.gltf',
        'Cesium Air' : '../../SampleData/models/CesiumAir/Cesium_Air.glb',
        'Shadow Tester' : '../../SampleData/models/ShadowTester/Shadow_Tester.gltf',
        'Shadow Tester 2' : '../../SampleData/models/ShadowTester/Shadow_Tester_2.gltf',
        'Shadow Tester 3' : '../../SampleData/models/ShadowTester/Shadow_Tester_3.gltf',
        'Shadow Tester 4' : '../../SampleData/models/ShadowTester/Shadow_Tester_4.gltf',
        'Shadow Tester Point' : '../../SampleData/models/ShadowTester/Shadow_Tester_Point.gltf'
    },
    locations : {
        'Exton' : {
            'centerLongitude' : -1.31968,
            'centerLatitude' : 0.698874,
            'offsetZ' : 20.0,
            'frustumSize' : 15,
            'frustumNear' : 1.0,
            'frustumFar' : 100.0,
            'tilt' : 0.0
        },
        'Everest' : {
            'centerLongitude' : 1.517132688,
            'centerLatitude' : 0.4884844964,
            'offsetZ' : 50.0,
            'frustumSize' : 55.0,
            'frustumNear' : 1.0,
            'frustumFar' : 400.0,
            'tilt' : 30.0
        },
        'Pinnacle PA' : {
            'centerLongitude' : -1.3324415110874286,
            'centerLatitude' : 0.6954224325279967,
            'offsetZ' : 236.6770689945084,
            'frustumSize' : 55.0,
            'frustumNear' : 1.0,
            'frustumFar' : 400.0,
            'tilt' : 30.0
        },
        'Seneca Rocks' : {
            'centerLongitude' : -1.38519677,
            'centerLatitude' : 0.67781497,
            'offsetZ' : 236.6770689945084,
            'frustumSize' : 55.0,
            'frustumNear' : 1.0,
            'frustumFar' : 400.0,
            'tilt' : 30.0
        },
        'Half Dome' : {
            'centerLongitude' : -2.0862479628,
            'centerLatitude' : 0.6587902522,
            'offsetZ' : 236.6770689945084,
            'frustumSize' : 55.0,
            'frustumNear' : 1.0,
            'frustumFar' : 400.0,
            'tilt' : 30.0
        }
    }
};

Cesium.knockout.track(viewModel);
var toolbar = document.getElementById('toolbar');
Cesium.knockout.applyBindings(viewModel, toolbar);
Cesium.knockout.getObservable(viewModel, 'lightAngle').subscribe(updateLightDirection);
Cesium.knockout.getObservable(viewModel, 'lightHorizon').subscribe(updateLightDirection);
Cesium.knockout.getObservable(viewModel, 'distance').subscribe(updateSettings);
Cesium.knockout.getObservable(viewModel, 'radius').subscribe(updateSettings);
Cesium.knockout.getObservable(viewModel, 'debug').subscribe(updateSettings);
Cesium.knockout.getObservable(viewModel, 'freeze').subscribe(updateSettings);
Cesium.knockout.getObservable(viewModel, 'shadows').subscribe(updateSettings);
Cesium.knockout.getObservable(viewModel, 'terrain').subscribe(updateLocation);
Cesium.knockout.getObservable(viewModel, 'globe').subscribe(updateSettings);
Cesium.knockout.getObservable(viewModel, 'terrainCast').subscribe(updateSettings);
Cesium.knockout.getObservable(viewModel, 'fitNearFar').subscribe(updateSettings);
Cesium.knockout.getObservable(viewModel, 'cascadeColors').subscribe(updateShadows);
Cesium.knockout.getObservable(viewModel, 'softShadows').subscribe(updateShadows);
Cesium.knockout.getObservable(viewModel, 'exponentialShadows').subscribe(updateShadows);
Cesium.knockout.getObservable(viewModel, 'cascades').subscribe(updateShadows);
Cesium.knockout.getObservable(viewModel, 'lightSource').subscribe(updateShadows);
Cesium.knockout.getObservable(viewModel, 'size').subscribe(updateSettings);
Cesium.knockout.getObservable(viewModel, 'model').subscribe(updateShadows);
Cesium.knockout.getObservable(viewModel, 'modelPosition').subscribe(updateShadows);
Cesium.knockout.getObservable(viewModel, 'grid').subscribe(updateShadows);
Cesium.knockout.getObservable(viewModel, 'location').subscribe(updateLocation);

for (var i = 0; i < viewModel.biasModes.length; ++i) {
    var biasMode = viewModel.biasModes[i];
    biasMode.polygonOffset.subscribe(updateShadows);
    biasMode.polygonOffsetFactor.subscribe(updateShadows);
    biasMode.polygonOffsetUnits.subscribe(updateShadows);
    biasMode.normalOffset.subscribe(updateShadows);
    biasMode.normalOffsetScale.subscribe(updateShadows);
    biasMode.normalShading.subscribe(updateShadows);
    biasMode.normalShadingSmooth.subscribe(updateShadows);
    biasMode.depthBias.subscribe(updateShadows);
}

var offset = new Cesium.Cartesian3();

function updateLightDirection() {
    var location = uiOptions.locations[viewModel.location];
    var center = Cesium.Cartesian3.fromRadians(location.centerLongitude, location.centerLatitude, location.height);
    var lightHorizon = Cesium.Math.toRadians(viewModel.lightHorizon);
    var lightAngle = Cesium.Math.toRadians(viewModel.lightAngle);
    offset.z = Math.cos(lightHorizon);
    offset.x = Math.sin(lightAngle) * (1.0 - offset.z);
    offset.y = Math.cos(lightAngle) * (1.0 - offset.z);

    freeformLightCamera.lookAt(center, offset);
}

function updateSettings() {
    shadowMap._maximumDistance = Number(viewModel.distance);
    shadowMap._radius = Number(viewModel.radius);
    shadowMap._fitNearFar = viewModel.fitNearFar;
    shadowMap.debugShow = viewModel.debug;
    shadowMap.debugFreezeFrame = viewModel.freeze;
    shadowMap.enabled = viewModel.shadows;
    shadowMap.setSize(viewModel.size);

    globe.castShadows = viewModel.terrainCast;
    globe.show = viewModel.globe;
    scene.skyAtmosphere.show = viewModel.globe;
}

function updateShadows() {
    var cascades = viewModel.cascades;
    var lightSource = viewModel.lightSource;
    var cascadeColors = viewModel.cascadeColors;
    var softShadows = viewModel.softShadows;
    var exponentialShadows = viewModel.exponentialShadows;

    var lightCamera;
    if (lightSource === 'Freeform') {
        lightCamera = freeformLightCamera;
    } else if (lightSource === 'Sun') {
        lightCamera = sunCamera;
    }

    if (lightSource === 'Fixed') {
        resetShadows({
            context : context,
            lightCamera : fixedLightCamera,
            cascadesEnabled : false,
            softShadows : softShadows
        });
    } else if (lightSource === 'Point') {
        resetShadows({
            context : context,
            lightCamera : pointLightCamera,
            isPointLight : true,
            softShadows : softShadows
        });
    } else if (lightSource === 'Spot') {
        resetShadows({
            context : context,
            lightCamera : spotLightCamera,
            cascadesEnabled : false,
            softShadows : softShadows
        });
    } else if (cascades === 4) {
        resetShadows({
            context : context,
            lightCamera : lightCamera,
            softShadows : softShadows
        });
        shadowMap.debugVisualizeCascades = cascadeColors;
    } else if (cascades === 1) {
        resetShadows({
            context : context,
            lightCamera : lightCamera,
            numberOfCascades : 1,
            softShadows : softShadows
        });
    }

    shadowMap._exponentialShadows = exponentialShadows;

    // Update biases
    for (var i = 0; i < viewModel.biasModes.length; ++i) {
        var biasMode = viewModel.biasModes[i];
        var bias = shadowMap['_' + biasMode.type + 'Bias'];
        bias.polygonOffset = biasMode.polygonOffset();
        bias.polygonOffsetFactor = biasMode.polygonOffsetFactor();
        bias.polygonOffsetUnits = biasMode.polygonOffsetUnits();
        bias.normalOffset = biasMode.normalOffset();
        bias.normalOffsetScale = biasMode.normalOffsetScale();
        bias.normalShading = biasMode.normalShading();
        bias.normalShadingSmooth = biasMode.normalShadingSmooth();
        bias.depthBias = biasMode.depthBias();
    }

    // Update render states for when polygon offset values change
    shadowMap._createRenderStates();

    updateSettings();
    updateUI();
}

function updateUI() {
    uiOptions.all.forEach(function(setting) {
        if (uiOptions.disable[viewModel.lightSource].indexOf(setting) > -1) {
            viewModel[setting + 'Enabled'] = false;
        } else {
            viewModel[setting + 'Enabled'] = true;
        }
    });
}

var viewer = new Cesium.Viewer('cesiumContainer', {
    scene3DOnly : true,
    infoBox : false,
    selectionIndicator : false,
    timeline : false
});

var scene = viewer.scene;
var context = scene.context;
var camera = scene.camera;
var globe = scene.globe;
var shadowMap;

scene.debugShowFramesPerSecond = true;

var fixedLightCamera = new Cesium.Camera(scene);
var freeformLightCamera = new Cesium.Camera(scene);
var sunCamera = scene._sunCamera;
var pointLightCamera = new Cesium.Camera(scene);
var spotLightCamera = new Cesium.Camera(scene);

var cesiumTerrainProvider = new Cesium.CesiumTerrainProvider({
    url : '//assets.agi.com/stk-terrain/world',
    requestWaterMask : true,
    requestVertexNormals : true
});

var ellipsoidTerrainProvider = new Cesium.EllipsoidTerrainProvider();

var imageryProvider = new Cesium.BingMapsImageryProvider({
    url : 'https://dev.virtualearth.net'
});

updateLocation();

function updateLocation() {
    // Get the height of the terrain at the given longitude/latitude, then create the scene.
    var location = uiOptions.locations[viewModel.location];
    var positions = [new Cesium.Cartographic(location.centerLongitude, location.centerLatitude)];
    var terrainProvider = viewModel.terrain ? cesiumTerrainProvider : ellipsoidTerrainProvider;
    var promise = Cesium.sampleTerrain(terrainProvider, 11, positions);
    Cesium.when(promise, function(updatedPositions) {
        location.height = updatedPositions[0].height + 50.0;
        createScene();
    });
}

function createScene() {
    var location = uiOptions.locations[viewModel.location];
    var center = Cesium.Cartesian3.fromRadians(location.centerLongitude, location.centerLatitude, location.height);

    var frustum = new Cesium.OrthographicFrustum();
    frustum.left = -location.frustumSize;
    frustum.right = location.frustumSize;
    frustum.bottom = -location.frustumSize;
    frustum.top = location.frustumSize;
    frustum.near = location.frustumNear;
    frustum.far = location.frustumFar;

    fixedLightCamera.frustum = frustum;
    fixedLightCamera.lookAt(center, new Cesium.Cartesian3(location.tilt, location.tilt, location.offsetZ));

    spotLightCamera.frustum.fov = Cesium.Math.PI_OVER_TWO;
    spotLightCamera.frustum.aspectRatio = 1.0;
    spotLightCamera.frustum.near = 1.0;
    spotLightCamera.frustum.far = 500.0;
    spotLightCamera.lookAt(center, new Cesium.Cartesian3(location.tilt, location.tilt, location.offsetZ));

    pointLightCamera.position = center;

    camera.lookAt(center, new Cesium.Cartesian3(25.0, 25.0, 30.0));

    updateLightDirection();
    updateShadows();
}

function resetGlobe() {
    globe = scene.globe = new Cesium.Globe();
    globe.imageryLayers.addImageryProvider(imageryProvider);
    globe.terrainProvider = viewModel.terrain ? cesiumTerrainProvider : ellipsoidTerrainProvider;
}

function resetShadows(shadowOptions) {
    // Changing the number of cascades or toggling cascade debug colors requires the receive-shadows shaders to recompile.
    // For testing purposes it is easier to clear the whole scene and start fresh rather than handling dynamic updates.
    scene.primitives.removeAll();

    var location = uiOptions.locations[viewModel.location];
    var centerLongitude = location.centerLongitude;
    var centerLatitude = location.centerLatitude;
    var height = location.height;

    resetGlobe();

    scene.shadowMap.destroy();
    scene.shadowMap = new Cesium.ShadowMap(shadowOptions);

    shadowMap = scene.shadowMap;
    shadowMap.enabled = true;
    shadowMap.debugShow = true;

    var position1 = Cesium.Cartesian3.fromRadians(centerLongitude, centerLatitude, height + 5.0);
    var position2 = Cesium.Cartesian3.fromRadians(centerLongitude, centerLatitude, height + 10.0);
    var position3 = Cesium.Cartesian3.fromRadians(centerLongitude, centerLatitude, height + 15.0);

    var modelHeight;
    if (viewModel.modelPosition === 'Ground') {
        modelHeight = height - 50.0;
    } else if (viewModel.modelPosition === 'Center') {
        modelHeight = height;
    }

    var modelPosition = Cesium.Cartesian3.fromRadians(centerLongitude, centerLatitude, modelHeight);

    createModel(uiOptions.modelUrls[viewModel.model], modelPosition);
    createBox(position3);
    createBoxRTC(position2);
    createSphere(position1);

    // Add a grid of models
    if (viewModel.grid) {
        var spacing = 0.00002;
        var gridSize = 10;
        for (var i = 0; i < gridSize * gridSize; ++i) {
            var x = i % gridSize;
            var y = Math.floor(i / gridSize);
            var longitude = centerLongitude + spacing * (x - gridSize / 2.0);
            var latitude = centerLatitude + spacing * (y - gridSize / 2.0);
            var position = Cesium.Cartesian3.fromRadians(longitude, latitude, modelHeight);
            createModel(uiOptions.modelUrls[viewModel.model], position);
        }
    }
}

function createModel(url, origin) {
    var modelMatrix = Cesium.Transforms.headingPitchRollToFixedFrame(origin, 0.0, 0.0, 0.0);

    var model = scene.primitives.add(Cesium.Model.fromGltf({
        url : url,
        modelMatrix : modelMatrix
    }));

    model.readyPromise.then(function(model) {
        // Play and loop all animations at half-speed
        model.activeAnimations.addAll({
            speedup : 0.5,
            loop : Cesium.ModelAnimationLoop.REPEAT
        });
    }).otherwise(function(error){
        window.alert(error);
    });

    return model;
}

function createBoxRTC(origin) {
    var modelMatrix = Cesium.Transforms.headingPitchRollToFixedFrame(origin, 0.0, 0.0, 0.0);

    var boxGeometry = Cesium.BoxGeometry.createGeometry(Cesium.BoxGeometry.fromDimensions({
        vertexFormat : Cesium.PerInstanceColorAppearance.VERTEX_FORMAT,
        dimensions : new Cesium.Cartesian3(1.0, 1.0, 1.0)
    }));

    var positions = boxGeometry.attributes.position.values;
    var newPositions = new Float32Array(positions.length);
    for (var i = 0; i < positions.length; ++i) {
        newPositions[i] = positions[i];
    }
    boxGeometry.attributes.position.values = newPositions;
    boxGeometry.attributes.position.componentDatatype = Cesium.ComponentDatatype.FLOAT;

    Cesium.BoundingSphere.transform(boxGeometry.boundingSphere, modelMatrix, boxGeometry.boundingSphere);

    var boxGeometryInstance = new Cesium.GeometryInstance({
        geometry : boxGeometry,
        attributes : {
            color : Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.BLUE)
        }
    });

    var box = new Cesium.Primitive({
        geometryInstances : boxGeometryInstance,
        appearance : new Cesium.PerInstanceColorAppearance({
            translucent : false,
            closed : true
        }),
        asynchronous : false,
        rtcCenter : boxGeometry.boundingSphere.center,
        castShadows : true,
        receiveShadows : true
    });

    scene.primitives.add(box);
}

function createBox(origin) {
    var modelMatrix = Cesium.Transforms.headingPitchRollToFixedFrame(origin, 0.0, 0.0, 0.0);

    var box = new Cesium.Primitive({
        geometryInstances : new Cesium.GeometryInstance({
            geometry : Cesium.BoxGeometry.fromDimensions({
                dimensions : new Cesium.Cartesian3(0.5, 0.5, 0.5),
                vertexFormat : Cesium.PerInstanceColorAppearance.VERTEX_FORMAT
            }),
            modelMatrix : modelMatrix,
            attributes : {
                color : Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.BLUE)
            }
        }),
        appearance : new Cesium.PerInstanceColorAppearance({
            translucent : false,
            closed : true
        }),
        asynchronous : false,
        castShadows : true,
        receiveShadows : true
    });

    scene.primitives.add(box);
}

function createSphere(origin) {
    var modelMatrix = Cesium.Transforms.headingPitchRollToFixedFrame(origin, 0.0, 0.0, 0.0);

    var sphere = new Cesium.Primitive({
        geometryInstances : new Cesium.GeometryInstance({
            geometry : new Cesium.SphereGeometry({
                radius : 2.0,
                vertexFormat : Cesium.PerInstanceColorAppearance.VERTEX_FORMAT
            }),
            modelMatrix : modelMatrix,
            attributes : {
                color : Cesium.ColorGeometryInstanceAttribute.fromColor(new Cesium.Color(1.0, 0.0, 0.0, 0.5))
            }
        }),
        appearance : new Cesium.PerInstanceColorAppearance({
            translucent : true,
            closed : true
        }),
        asynchronous : false,
        castShadows : true,
        receiveShadows : true
    });

    scene.primitives.add(sphere);
}

var canvas = viewer.canvas;
canvas.setAttribute('tabindex', '0'); // needed to put focus on the canvas
canvas.onclick = function() {
    // To get key events
    canvas.focus();
};

var handler = new Cesium.ScreenSpaceEventHandler(canvas);

// Double click object to turn castShadows on/off
handler.setInputAction(function(movement) {
    var picked = scene.pick(movement.position);
    if (Cesium.defined(picked) && Cesium.defined(picked.primitive)) {
        picked.primitive.castShadows = !picked.primitive.castShadows;
    }
}, Cesium.ScreenSpaceEventType.LEFT_DOUBLE_CLICK);

// Double middle click object to turn receiveShadows on/off
handler.setInputAction(function(movement) {
    var picked = scene.pick(movement.position);
    if (Cesium.defined(picked)) {
        picked.primitive.receiveShadows = !picked.primitive.receiveShadows;
    }
}, Cesium.ScreenSpaceEventType.MIDDLE_DOUBLE_CLICK);


//Sandcastle_End
Sandcastle.finishedLoading();
}
if (typeof Cesium !== "undefined") {
    startup(Cesium);
} else if (typeof require === "function") {
    require(["Cesium"], startup);
}
</script>
</body>
</html>
